{"version":3,"sources":["types/GridTypes.ts","components/table/cell/Cell.tsx","algorithms/AbstractAlgorithm.ts","data-structures/MinHeap.ts","utils/Utils.ts","algorithms/Dijkstra.ts","components/table/grid/Grid.tsx","pages/main.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["OnClickEventType","getClass","cell","result","push","isStart","isFinish","join","Cell","props","id","coordinate","row","col","onClick","onClickHandler","className","cellToNode","distance","prev","AbstractAlgorithm","MinHeap","data","this","item","reorganize","length","index","parentIndex","Math","floor","parentVal","pushedVal","swap","max","tmp","pop","ret","temp","i","rightChildIndex","leftChildIndex","lowest","isEqual","obj1","obj2","JSON","stringify","Dijkstra","grid","startCell","endCell","start","end","finishNode","visitedCellsInOrder","minHeap","insert","isFinished","curr","removeTop","console","log","findNeighbors","forEach","n","includes","filter","md","node","neighbors","shortestPath","reverse","INIT_START","INIT_END","Grid","config","useState","setGrid","SET_START","onClickType","setOnClickType","setStartCell","setEndCell","isRunning","setRunning","visitedElements","setVisitedElements","animate","visited","visitedEl","setTimeout","currCell","el","document","getElementById","classList","add","clearBoard","remove","useEffect","numRows","currRow","numColumns","computeInitialGrid","type","value","name","checked","onChange","SET_FINISH","disabled","dijkstra","visitedCells","compute","getShortestPath","startDijkstra","map","rowIdx","cellIdx","handleOnClick","gridConfiguration","Main","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.a86a3d71.chunk.js","sourcesContent":["export interface GridConfiguration {\r\n    numColumns: number,\r\n    numRows: number\r\n}\r\n\r\nexport interface ICoordinate {\r\n    row: number,\r\n    col: number\r\n}\r\n\r\nexport interface ICell {\r\n    coordinate: ICoordinate,\r\n    isStart: boolean,\r\n    isFinish: boolean\r\n}\r\n\r\nexport interface INode {\r\n    cell: ICell,\r\n    distance: number,\r\n    prev: INode | null\r\n}\r\n\r\nexport enum OnClickEventType {\r\n    SET_FINISH,\r\n    SET_START\r\n}\r\n\r\nexport function cellToNode(cell: ICell, distance: number, prev: INode): INode {\r\n    return {\r\n        cell: cell,\r\n        distance: distance,\r\n        prev: prev\r\n    }\r\n}\r\n","import React from 'react';\r\nimport \"./Cell.css\"\r\nimport {ICell} from \"../../../types/GridTypes\";\r\n\r\ninterface CellProps {\r\n    cell: ICell,\r\n    onClickHandler: Function\r\n}\r\n\r\nconst getClass = (cell: ICell) => {\r\n    let result = [\"cell\"];\r\n    result.push(\r\n        (cell.isStart ? \"cell--is-start\" :\r\n            cell.isFinish ? \"cell--is-finish\" : \"\"));\r\n\r\n    return result.join(\" \");\r\n};\r\n\r\nconst Cell = (props: CellProps) => {\r\n    return (\r\n        <div id={\"cell-\" + props.cell.coordinate.row + \"-\" + props.cell.coordinate.col}\r\n             onClick={() => props.onClickHandler(props.cell)} className={getClass(props.cell)}/>\r\n    );\r\n};\r\n\r\nexport default Cell;\r\n","import {ICell} from \"../types/GridTypes\";\r\n\r\nexport abstract class AbstractAlgorithm {\r\n    abstract compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell>;\r\n}\r\n","/**\r\n * Binary heap (min-heap) used for dijkstra algorithm\r\n * Reference: https://medium.com/dev-genius/how-to-implement-a-binary-heap-javascript-d3a0c54112fa\r\n *\r\n * Insert: O(logn)\r\n * GetMin: O(logn)\r\n */\r\nimport {INode} from \"../types/GridTypes\";\r\n\r\nexport class MinHeap {\r\n    data: Array<INode>;\r\n\r\n    constructor() {\r\n        this.data = []\r\n    }\r\n\r\n    public insert(item: INode): void {\r\n        this.data.push(item);\r\n        this.reorganize(this.data.length - 1);\r\n    }\r\n\r\n    /**\r\n     * Reorganizes values in heap\r\n     */\r\n    private reorganize(index: number) {\r\n        let parentIndex = Math.floor((index + 1) / 2 - 1);\r\n        if (parentIndex < 0) parentIndex = 0;\r\n\r\n        let parentVal = this.data[parentIndex].distance;\r\n        const pushedVal = this.data[index].distance;\r\n        while (index > 0 && parentVal > pushedVal) {\r\n            parentIndex = Math.floor((index + 1) / 2 - 1);\r\n            this.swap(index, parentIndex);\r\n            index = parentIndex;\r\n            parentVal = this.data[Math.max(Math.floor((index + 1) / 2 - 1), 0)].distance;\r\n        }\r\n    }\r\n\r\n    private swap(index: number, parentIndex: number) {\r\n        let tmp = this.data[parentIndex]\r\n        this.data[parentIndex] = this.data[index];\r\n        this.data[index] = tmp;\r\n    }\r\n\r\n    /**\r\n     * Removes top element from heap\r\n     */\r\n    public removeTop(): INode | undefined {\r\n        if (this.data.length <= 1) return this.data.pop();\r\n\r\n        const ret: INode = this.data[0]; // What we will return\r\n        let temp = this.data.pop();\r\n        if (!temp) return temp;\r\n\r\n        this.data[0] = temp; // Place last element in array at front\r\n        let i = 0; // We adjust heap from top to down\r\n\r\n        while (true) {\r\n            let rightChildIndex = (i + 1) * 2;\r\n            let leftChildIndex = (i + 1) * 2 - 1;\r\n            let lowest = rightChildIndex;\r\n            if (leftChildIndex >= this.data.length && rightChildIndex >= this.data.length) break;\r\n\r\n            if (leftChildIndex >= this.data.length) lowest = rightChildIndex;\r\n            if (rightChildIndex >= this.data.length) lowest = leftChildIndex;\r\n\r\n            // Find the smallest child\r\n            if (!(leftChildIndex >= this.data.length) && !(rightChildIndex >= this.data.length)) {\r\n                lowest = this.data[rightChildIndex].distance < this.data[leftChildIndex].distance ? rightChildIndex : leftChildIndex;\r\n            }\r\n\r\n            // If the parent is greater than the smallest child: swap\r\n            if (this.data[i].distance > this.data[lowest].distance) {\r\n                this.swap(i, lowest);\r\n                i = lowest;\r\n            } else break;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","export function isEqual(obj1: Object, obj2: Object): boolean {\r\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\r\n}\r\n","import {AbstractAlgorithm} from \"./AbstractAlgorithm\";\r\nimport {cellToNode, ICell, INode} from \"../types/GridTypes\";\r\nimport {MinHeap} from \"../data-structures/MinHeap\";\r\nimport {isEqual} from \"../utils/Utils\";\r\n\r\n/**\r\n * Dijkstra is a Greedy algorithm\r\n *\r\n * Steps:\r\n * 1. Initialize start node with distance 0\r\n * 2. Get node with minimum distance from heap and add as visited\r\n * 3. getNeighbors from minimum distance node\r\n * 4. Remove current top node from heap and add Neighbor nodes to heap\r\n * 5. Repeat from 2 until endCell found\r\n */\r\nexport class Dijkstra extends AbstractAlgorithm {\r\n    private readonly grid: Array<ICell[]>;\r\n    private readonly start: ICell;\r\n    private end: ICell;\r\n    // needed for shortest path\r\n    private finishNode: INode | null;\r\n\r\n    constructor(grid: Array<ICell[]>, startCell: ICell, endCell: ICell) {\r\n        super();\r\n        this.grid = grid;\r\n        this.start = startCell;\r\n        this.end = endCell;\r\n        this.finishNode = null;\r\n    }\r\n\r\n    compute(): Array<ICell> {\r\n        let visitedCellsInOrder: Array<ICell> = [];\r\n\r\n        const start = {\r\n            cell: this.start,\r\n            distance: 0,\r\n            prev: null\r\n        };\r\n        let minHeap = new MinHeap();\r\n        minHeap.insert(start);\r\n\r\n        let isFinished = false;\r\n        while (!isFinished) {\r\n            let curr: INode | undefined = minHeap.removeTop();\r\n            if (curr) {\r\n                if (!curr.cell.isStart) {\r\n                    visitedCellsInOrder.push(curr.cell);\r\n                }\r\n\r\n                let neighbors: Array<INode> = this.findNeighbors(curr);\r\n                neighbors.forEach(n => {\r\n                    if (isEqual(n.cell.coordinate, this.end.coordinate)) {\r\n                        isFinished = true;\r\n                        this.finishNode = n;\r\n                    } else if (!visitedCellsInOrder.includes(n.cell) && !minHeap.data.includes(n)\r\n                        && minHeap.data.filter(md => isEqual(md.cell.coordinate, n.cell.coordinate)).length === 0) {\r\n                        minHeap.insert(n);\r\n                    }\r\n                });\r\n            } else {\r\n                console.log(\"Undefined node\")\r\n                break;\r\n            }\r\n        }\r\n\r\n        return visitedCellsInOrder;\r\n    }\r\n\r\n    private findNeighbors(node: INode) {\r\n        let neighbors: Array<INode> = [];\r\n        let {coordinate} = node.cell;\r\n\r\n        if (this.grid[coordinate.row + 1]) {\r\n            neighbors.push(cellToNode(this.grid[coordinate.row + 1][coordinate.col], node.distance + 1, node))\r\n        }\r\n        if (this.grid[coordinate.row - 1]) {\r\n            neighbors.push(cellToNode(this.grid[coordinate.row - 1][coordinate.col], node.distance + 1, node))\r\n        }\r\n        if (this.grid[coordinate.row][coordinate.col + 1]) {\r\n            neighbors.push(cellToNode(this.grid[coordinate.row][coordinate.col + 1], node.distance + 1, node))\r\n        }\r\n        if (this.grid[coordinate.row][coordinate.col - 1]) {\r\n            neighbors.push(cellToNode(this.grid[coordinate.row][coordinate.col - 1], node.distance + 1, node))\r\n        }\r\n\r\n        return neighbors;\r\n    }\r\n\r\n    public getShortestPath(): Array<ICell> {\r\n        let shortestPath: Array<ICell> = [];\r\n\r\n        if (this.finishNode) {\r\n            let curr: INode = this.finishNode\r\n            while (curr?.prev) {\r\n                if (!curr.cell.isStart && !curr.cell.isFinish) {\r\n                    shortestPath.push(curr.cell);\r\n                }\r\n                curr = curr.prev;\r\n            }\r\n        }\r\n\r\n        return shortestPath.reverse();\r\n    }\r\n}\r\n","import React, {useEffect, useState} from 'react';\r\nimport \"./Grid.css\"\r\nimport Cell from \"../cell/Cell\";\r\nimport {GridConfiguration, ICell, OnClickEventType} from \"../../../types/GridTypes\";\r\nimport {Dijkstra} from \"../../../algorithms/Dijkstra\";\r\n\r\nlet INIT_START: ICell = {\r\n    coordinate: {\r\n        row: 10,\r\n        col: 5\r\n    },\r\n    isStart: true,\r\n    isFinish: false,\r\n};\r\n\r\nlet INIT_END: ICell = {\r\n    coordinate: {\r\n        row: 14,\r\n        col: 15\r\n    },\r\n    isStart: false,\r\n    isFinish: true,\r\n};\r\n\r\nconst computeInitialGrid = (config: GridConfiguration, startCell: ICell, endCell: ICell): Array<ICell[]> => {\r\n    let grid = []\r\n    for (let row = 0; row < config.numRows; row++) {\r\n        let currRow: ICell[] = [];\r\n\r\n        for (let col = 0; col < config.numColumns; col++) {\r\n            currRow.push({\r\n                isStart: col === startCell.coordinate.col && row === startCell.coordinate.row,\r\n                isFinish: col === endCell.coordinate.col && row === endCell.coordinate.row,\r\n                coordinate: {\r\n                    row: row,\r\n                    col: col\r\n                },\r\n            })\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst Grid = (config: GridConfiguration) => {\r\n    const [grid, setGrid] = useState<Array<ICell[]>>([[]]);\r\n    const [onClickType, setOnClickType] = useState<OnClickEventType>(OnClickEventType.SET_START);\r\n    const [startCell, setStartCell] = useState<ICell>(INIT_START);\r\n    const [endCell, setEndCell] = useState<ICell>(INIT_END);\r\n    const [isRunning, setRunning] = useState(false);\r\n    const [visitedElements, setVisitedElements] = useState<Array<Element>>([]);\r\n\r\n    const handleOnClick = (cell: ICell) => {\r\n        if (isRunning) return\r\n\r\n        switch (onClickType) {\r\n            case OnClickEventType.SET_START:\r\n                startCell.isStart = false;\r\n                cell.isStart = true\r\n                setStartCell(cell);\r\n                break;\r\n            case OnClickEventType.SET_FINISH:\r\n                endCell.isFinish = false;\r\n                cell.isFinish = true\r\n                setEndCell(cell);\r\n                break;\r\n        }\r\n    };\r\n\r\n    const startDijkstra = () => {\r\n        clearBoard();\r\n        setRunning(true)\r\n        const dijkstra = new Dijkstra(grid, startCell, endCell);\r\n        const visitedCells = dijkstra.compute();\r\n        const shortestPath = dijkstra.getShortestPath();\r\n        animate(visitedCells, shortestPath);\r\n    }\r\n\r\n    const animate = (visited: Array<ICell>, shortestPath: Array<ICell>) => {\r\n        let visitedEl: Array<Element> = []\r\n        for (let i = 0; i < visited.length; i++) {\r\n            setTimeout(() => {\r\n                let currCell = visited[i]\r\n                let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                if (el) {\r\n                    el.classList.add(\"cell--is-visited\");\r\n                    visitedEl.push(el)\r\n                }\r\n            }, 10 * i)\r\n        }\r\n\r\n        // wait till first timeout until\r\n        setTimeout(() => {\r\n            // animate shortest path\r\n            for (let i = 0; i < shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    let currCell = shortestPath[i]\r\n                    let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                    if (el) {\r\n                        el.classList.add(\"cell--is-shortest-path\");\r\n                        visitedEl.push(el)\r\n                    }\r\n                }, 30 * i)\r\n            }\r\n\r\n            setTimeout(() => {\r\n                setVisitedElements(visitedEl);\r\n                setRunning(false)\r\n            }, 10 * shortestPath.length)\r\n        }, 10 * visited.length)\r\n    }\r\n\r\n    const clearBoard = () => {\r\n        for (let el of visitedElements) {\r\n            el.classList.remove(\"cell--is-visited\")\r\n            el.classList.remove(\"cell--is-shortest-path\")\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        clearBoard();\r\n        setGrid(computeInitialGrid(config, startCell, endCell));\r\n    }, [config, startCell, endCell])\r\n\r\n    return (\r\n        <div>\r\n            <div>\r\n                <input type=\"radio\" value={OnClickEventType.SET_START} name=\"onClickEventType\"\r\n                       checked={onClickType === OnClickEventType.SET_START}\r\n                       onChange={() => setOnClickType(OnClickEventType.SET_START)}/> Set Start\r\n                <input type=\"radio\" value={OnClickEventType.SET_FINISH} name=\"onClickEventType\"\r\n                       checked={onClickType === OnClickEventType.SET_FINISH}\r\n                       onChange={() => setOnClickType(OnClickEventType.SET_FINISH)}/> Set Finish\r\n\r\n                <button disabled=\r\n                            {isRunning} onClick={() => startDijkstra()}>Start Dijkstra Algorithm\r\n                </button>\r\n                <div className=\"grid__container\">\r\n                    {\r\n                        grid.map((row, rowIdx) => {\r\n                            return <div key={rowIdx} className=\"grid__container__row\">\r\n                                {row.map((cell, cellIdx) => <Cell key={cellIdx} cell={cell}\r\n                                                                  onClickHandler={(cell: ICell) => handleOnClick(cell)}/>)}\r\n                            </div>\r\n                        })\r\n                    }\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Grid;\r\n","import React from 'react';\r\nimport Grid from \"../components/table/grid/Grid\";\r\nimport {GridConfiguration} from \"../types/GridTypes\";\r\n\r\nconst gridConfiguration: GridConfiguration = {\r\n    numColumns: 50,\r\n    numRows: 20\r\n};\r\n\r\nconst Main = () => {\r\n    return (\r\n        <div>\r\n            <Grid {...gridConfiguration} />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Main;\r\n","import React from 'react';\nimport './App.css';\nimport Main from \"./pages/main\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Main/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}