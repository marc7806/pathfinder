{"version":3,"sources":["types/GridTypes.ts","components/table/cell/Cell.tsx","algorithms/AbstractAlgorithm.ts","data-structures/MinHeap.ts","utils/Utils.ts","algorithms/Dijkstra.ts","components/table/grid/Grid.tsx","pages/main.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["OnClickEventType","getClass","cell","result","push","isStart","isFinish","isWall","join","Cell","props","useState","setReload","id","coordinate","row","col","onClick","onClickHandler","onMouseDown","onMouseDownHandler","onMouseUp","onMouseUpHandler","onMouseUpCapture","onMouseEnter","onMouseEnterHandler","onMouseLeave","rel","className","cellToNode","distance","prev","AbstractAlgorithm","finishNode","this","node","grid","neighbors","n","MinHeap","data","item","reorganize","length","index","parentIndex","Math","floor","parentVal","pushedVal","swap","max","tmp","pop","ret","temp","i","rightChildIndex","leftChildIndex","lowest","isEqual","obj1","obj2","JSON","stringify","Dijkstra","startCell","endCell","visitedCellsInOrder","start","minHeap","insert","isFinished","curr","removeTop","console","log","findNeighbors","forEach","includes","filter","md","shortestPath","reverse","INIT_START","INIT_END","Grid","config","setGrid","name","instance","algorithm","setAlgorithm","SET_START","onClickType","setOnClickType","setStartCell","setEndCell","isRunning","setRunning","visitedElements","setVisitedElements","isMouseDown","setMouseDown","animate","visited","visitedEl","setTimeout","currCell","el","document","getElementById","classList","add","clearBoard","remove","useEffect","numRows","currRow","numColumns","computeInitialGrid","handleMouseUp","window","removeEventListener","onChange","e","algorithms","parseInt","target","value","handleAlgorithmSelection","map","algo","idx","disabled","visitedCells","compute","getShortestPath","startAlgorithm","style","display","justifyContent","type","checked","htmlFor","SET_FINISH","SET_WALL","REMOVE_WALL","rowIdx","cellIdx","addEventListener","handleOnMouseEnter","handleOnClick","gridConfiguration","Main","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.464e3def.chunk.js","sourcesContent":["import {AbstractAlgorithm} from \"../algorithms/AbstractAlgorithm\";\r\n\r\nexport interface GridConfiguration {\r\n    numColumns: number,\r\n    numRows: number,\r\n    algorithms: Array<Algorithm>\r\n}\r\n\r\nexport interface ICoordinate {\r\n    row: number,\r\n    col: number\r\n}\r\n\r\nexport interface ICell {\r\n    coordinate: ICoordinate,\r\n    isStart: boolean,\r\n    isFinish: boolean,\r\n    isWall: boolean\r\n}\r\n\r\nexport interface INode {\r\n    cell: ICell,\r\n    distance: number,\r\n    prev: INode | null\r\n}\r\n\r\nexport interface Algorithm {\r\n    name: String,\r\n    instance: AbstractAlgorithm\r\n}\r\n\r\nexport enum OnClickEventType {\r\n    SET_FINISH,\r\n    SET_START,\r\n    SET_WALL,\r\n    REMOVE_WALL\r\n}\r\n\r\nexport function cellToNode(cell: ICell, distance: number, prev: INode): INode {\r\n    return {\r\n        cell: cell,\r\n        distance: distance,\r\n        prev: prev\r\n    }\r\n}\r\n","import React, {useState} from 'react';\r\nimport \"./Cell.css\"\r\nimport {ICell} from \"../../../types/GridTypes\";\r\n\r\ninterface CellProps {\r\n    cell: ICell,\r\n    onClickHandler: Function,\r\n    onMouseDownHandler: Function,\r\n    onMouseUpHandler: Function,\r\n    onMouseEnterHandler: Function\r\n}\r\n\r\nconst getClass = (cell: ICell) => {\r\n    let result = [\"cell\"];\r\n    result.push(\r\n        (cell.isStart ? \"cell--is-start\" :\r\n            cell.isFinish ? \"cell--is-finish\" :\r\n                cell.isWall ? \"cell--is-wall\" : \"\"));\r\n\r\n    return result.join(\" \");\r\n};\r\n\r\nconst Cell = (props: CellProps) => {\r\n    // to enforce state reload...\r\n    const [reload, setReload] = useState<boolean>(false);\r\n\r\n    return (\r\n        <div id={\"cell-\" + props.cell.coordinate.row + \"-\" + props.cell.coordinate.col}\r\n             onClick={() => props.onClickHandler(props.cell)}\r\n             onMouseDown={() => props.onMouseDownHandler()}\r\n             onMouseUp={() => props.onMouseUpHandler()}\r\n             onMouseUpCapture={() => props.onMouseUpHandler()}\r\n             onMouseEnter={() => props.onMouseEnterHandler(props.cell)}\r\n             onMouseLeave={() => setReload(rel => !rel)}\r\n             className={getClass(props.cell)}\r\n        />\r\n    );\r\n};\r\n\r\nexport default Cell;\r\n","import {cellToNode, ICell, INode} from \"../types/GridTypes\";\r\n\r\nexport abstract class AbstractAlgorithm {\r\n    protected finishNode: INode | null;\r\n\r\n    protected constructor() {\r\n        this.finishNode = null;\r\n    }\r\n\r\n    abstract compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell>;\r\n\r\n    abstract getShortestPath(): Array<ICell>;\r\n\r\n    protected findNeighbors(node: INode, grid: Array<ICell[]>) {\r\n        let neighbors: Array<INode> = [];\r\n        let {coordinate} = node.cell;\r\n\r\n        if (grid[coordinate.row + 1]) {\r\n            const n = grid[coordinate.row + 1][coordinate.col];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row - 1]) {\r\n            const n = grid[coordinate.row - 1][coordinate.col];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row][coordinate.col + 1]) {\r\n            const n = grid[coordinate.row][coordinate.col + 1];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row][coordinate.col - 1]) {\r\n            const n = grid[coordinate.row][coordinate.col - 1];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, node))\r\n            }\r\n        }\r\n\r\n        return neighbors;\r\n    }\r\n}\r\n","/**\r\n * Binary heap (min-heap) used for dijkstra algorithm\r\n * Reference: https://medium.com/dev-genius/how-to-implement-a-binary-heap-javascript-d3a0c54112fa\r\n *\r\n * Insert: O(logn)\r\n * GetMin: O(logn)\r\n */\r\nimport {INode} from \"../types/GridTypes\";\r\n\r\nexport class MinHeap {\r\n    data: Array<INode>;\r\n\r\n    constructor() {\r\n        this.data = []\r\n    }\r\n\r\n    public insert(item: INode): void {\r\n        this.data.push(item);\r\n        this.reorganize(this.data.length - 1);\r\n    }\r\n\r\n    /**\r\n     * Reorganizes values in heap\r\n     */\r\n    private reorganize(index: number) {\r\n        let parentIndex = Math.floor((index + 1) / 2 - 1);\r\n        if (parentIndex < 0) parentIndex = 0;\r\n\r\n        let parentVal = this.data[parentIndex].distance;\r\n        const pushedVal = this.data[index].distance;\r\n        while (index > 0 && parentVal > pushedVal) {\r\n            parentIndex = Math.floor((index + 1) / 2 - 1);\r\n            this.swap(index, parentIndex);\r\n            index = parentIndex;\r\n            parentVal = this.data[Math.max(Math.floor((index + 1) / 2 - 1), 0)].distance;\r\n        }\r\n    }\r\n\r\n    private swap(index: number, parentIndex: number) {\r\n        let tmp = this.data[parentIndex]\r\n        this.data[parentIndex] = this.data[index];\r\n        this.data[index] = tmp;\r\n    }\r\n\r\n    /**\r\n     * Removes top element from heap\r\n     */\r\n    public removeTop(): INode | undefined {\r\n        if (this.data.length <= 1) return this.data.pop();\r\n\r\n        const ret: INode = this.data[0]; // What we will return\r\n        let temp = this.data.pop();\r\n        if (!temp) return temp;\r\n\r\n        this.data[0] = temp; // Place last element in array at front\r\n        let i = 0; // We adjust heap from top to down\r\n\r\n        while (true) {\r\n            let rightChildIndex = (i + 1) * 2;\r\n            let leftChildIndex = (i + 1) * 2 - 1;\r\n            let lowest = rightChildIndex;\r\n            if (leftChildIndex >= this.data.length && rightChildIndex >= this.data.length) break;\r\n\r\n            if (leftChildIndex >= this.data.length) lowest = rightChildIndex;\r\n            if (rightChildIndex >= this.data.length) lowest = leftChildIndex;\r\n\r\n            // Find the smallest child\r\n            if (!(leftChildIndex >= this.data.length) && !(rightChildIndex >= this.data.length)) {\r\n                lowest = this.data[rightChildIndex].distance < this.data[leftChildIndex].distance ? rightChildIndex : leftChildIndex;\r\n            }\r\n\r\n            // If the parent is greater than the smallest child: swap\r\n            if (this.data[i].distance > this.data[lowest].distance) {\r\n                this.swap(i, lowest);\r\n                i = lowest;\r\n            } else break;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","export function isEqual(obj1: Object, obj2: Object): boolean {\r\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\r\n}\r\n","import {AbstractAlgorithm} from \"./AbstractAlgorithm\";\r\nimport {ICell, INode} from \"../types/GridTypes\";\r\nimport {MinHeap} from \"../data-structures/MinHeap\";\r\nimport {isEqual} from \"../utils/Utils\";\r\n\r\n/**\r\n * Dijkstra is a Greedy algorithm\r\n *\r\n * Steps:\r\n * 1. Initialize start node with distance 0\r\n * 2. Get node with minimum distance from heap and add as visited\r\n * 3. getNeighbors from minimum distance node\r\n * 4. Remove current top node from heap and add Neighbor nodes to heap\r\n * 5. Repeat from 2 until endCell found\r\n */\r\nexport class Dijkstra extends AbstractAlgorithm {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell> {\r\n        this.finishNode = null;\r\n        let visitedCellsInOrder: Array<ICell> = [];\r\n\r\n        const start = {\r\n            cell: startCell,\r\n            distance: 0,\r\n            prev: null\r\n        };\r\n        let minHeap = new MinHeap();\r\n        minHeap.insert(start);\r\n\r\n        let isFinished = false;\r\n        while (!isFinished) {\r\n            let curr: INode | undefined = minHeap.removeTop();\r\n            if (curr) {\r\n                if (!curr.cell.isStart && !curr.cell.isWall) {\r\n                    visitedCellsInOrder.push(curr.cell);\r\n                }\r\n\r\n                let neighbors: Array<INode> = this.findNeighbors(curr, grid);\r\n                neighbors.forEach(n => {\r\n                    if (isEqual(n.cell.coordinate, endCell.coordinate)) {\r\n                        isFinished = true;\r\n                        this.finishNode = n;\r\n                    } else if (!visitedCellsInOrder.includes(n.cell) && !minHeap.data.includes(n)\r\n                        && minHeap.data.filter(md => isEqual(md.cell.coordinate, n.cell.coordinate)).length === 0) {\r\n                        minHeap.insert(n);\r\n                    }\r\n                });\r\n            } else {\r\n                console.log(\"Undefined node\")\r\n                break;\r\n            }\r\n        }\r\n\r\n        return visitedCellsInOrder;\r\n    }\r\n\r\n    getShortestPath(): Array<ICell> {\r\n        let shortestPath: Array<ICell> = [];\r\n\r\n        if (this.finishNode) {\r\n            let curr: INode = this.finishNode\r\n            while (curr?.prev) {\r\n                if (!curr.cell.isStart && !curr.cell.isFinish) {\r\n                    shortestPath.push(curr.cell);\r\n                }\r\n                curr = curr.prev;\r\n            }\r\n        }\r\n\r\n        return shortestPath.reverse();\r\n    }\r\n}\r\n","import React, {useEffect, useState} from 'react';\r\nimport \"./Grid.css\"\r\nimport Cell from \"../cell/Cell\";\r\nimport {Algorithm, GridConfiguration, ICell, OnClickEventType} from \"../../../types/GridTypes\";\r\nimport {Dijkstra} from \"../../../algorithms/Dijkstra\";\r\n\r\nlet INIT_START: ICell = {\r\n    coordinate: {\r\n        row: 10,\r\n        col: 5\r\n    },\r\n    isStart: true,\r\n    isFinish: false,\r\n    isWall: false\r\n};\r\n\r\nlet INIT_END: ICell = {\r\n    coordinate: {\r\n        row: 14,\r\n        col: 15\r\n    },\r\n    isStart: false,\r\n    isFinish: true,\r\n    isWall: false\r\n};\r\n\r\nconst computeInitialGrid = (config: GridConfiguration, startCell: ICell, endCell: ICell): Array<ICell[]> => {\r\n    let grid = []\r\n    for (let row = 0; row < config.numRows; row++) {\r\n        let currRow: ICell[] = [];\r\n\r\n        for (let col = 0; col < config.numColumns; col++) {\r\n            currRow.push({\r\n                isStart: col === startCell.coordinate.col && row === startCell.coordinate.row,\r\n                isFinish: col === endCell.coordinate.col && row === endCell.coordinate.row,\r\n                isWall: false,\r\n                coordinate: {\r\n                    row: row,\r\n                    col: col\r\n                },\r\n            })\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst Grid = (config: GridConfiguration) => {\r\n    const [grid, setGrid] = useState<Array<ICell[]>>([[]]);\r\n    const [algorithm, setAlgorithm] = useState<Algorithm>({name: \"\", instance: new Dijkstra()});\r\n    const [onClickType, setOnClickType] = useState<OnClickEventType>(OnClickEventType.SET_START);\r\n    const [startCell, setStartCell] = useState<ICell>(INIT_START);\r\n    const [endCell, setEndCell] = useState<ICell>(INIT_END);\r\n    const [isRunning, setRunning] = useState(false);\r\n    const [visitedElements, setVisitedElements] = useState<Array<Element>>([]);\r\n    const [isMouseDown, setMouseDown] = useState<boolean>(false);\r\n\r\n    const handleOnClick = (cell: ICell) => {\r\n        if (isRunning) return\r\n\r\n        switch (onClickType) {\r\n            case OnClickEventType.SET_START:\r\n                startCell.isStart = false;\r\n                cell.isStart = true\r\n                setStartCell(cell);\r\n                clearBoard();\r\n                break;\r\n            case OnClickEventType.SET_FINISH:\r\n                endCell.isFinish = false;\r\n                cell.isFinish = true\r\n                setEndCell(cell);\r\n                clearBoard();\r\n                break;\r\n        }\r\n    };\r\n\r\n    const startAlgorithm = () => {\r\n        clearBoard();\r\n        setRunning(true)\r\n        const visitedCells = algorithm.instance.compute(grid, startCell, endCell);\r\n        const shortestPath = algorithm.instance.getShortestPath();\r\n        animate(visitedCells, shortestPath);\r\n    }\r\n\r\n    const animate = (visited: Array<ICell>, shortestPath: Array<ICell>) => {\r\n        let visitedEl: Array<Element> = []\r\n        for (let i = 0; i < visited.length; i++) {\r\n            setTimeout(() => {\r\n                let currCell = visited[i]\r\n                let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                if (el) {\r\n                    el.classList.add(\"cell--is-visited\");\r\n                    visitedEl.push(el)\r\n                }\r\n            }, 10 * i)\r\n        }\r\n\r\n        // show shortest path after visited nodes are visualized\r\n        setTimeout(() => {\r\n            // animate shortest path\r\n            for (let i = 0; i < shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    let currCell = shortestPath[i]\r\n                    let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                    if (el) {\r\n                        el.classList.add(\"cell--is-shortest-path\");\r\n                    }\r\n                }, 30 * i)\r\n            }\r\n\r\n            setTimeout(() => {\r\n                setVisitedElements(visitedEl);\r\n                setRunning(false)\r\n            }, 10 * shortestPath.length)\r\n        }, 10 * visited.length)\r\n    }\r\n\r\n    const clearBoard = () => {\r\n        for (let el of visitedElements) {\r\n            el.classList.remove(\"cell--is-visited\")\r\n            el.classList.remove(\"cell--is-shortest-path\")\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        setGrid(computeInitialGrid(config, startCell, endCell));\r\n    }, [config, startCell, endCell])\r\n\r\n    const handleAlgorithmSelection = (e: React.ChangeEvent<HTMLSelectElement>) => {\r\n        setAlgorithm(config.algorithms[parseInt(e.target.value)])\r\n    }\r\n\r\n    const handleMouseDown = () => {\r\n        setMouseDown(true);\r\n        window.addEventListener('mouseup', handleMouseUp, true)\r\n    }\r\n\r\n    const handleMouseUp = () => {\r\n        setMouseDown(false);\r\n        window.removeEventListener('mouseup', handleMouseUp, true);\r\n    }\r\n\r\n    const handleOnMouseEnter = (cell: ICell) => {\r\n        if (isMouseDown && !isRunning) {\r\n            if (onClickType === OnClickEventType.SET_WALL) {\r\n                cell.isWall = true\r\n            } else if (onClickType === OnClickEventType.REMOVE_WALL) {\r\n                cell.isWall = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <div className=\"algorithm-selection\">\r\n                <label>Select Algorithm:</label>\r\n                <div className=\"custom-select\">\r\n                    <select onChange={(e) => handleAlgorithmSelection(e)}>\r\n                        {\r\n                            config.algorithms.map((algo, idx) => {\r\n                                return <option key={idx} value={idx}>{algo.name}</option>\r\n                            })\r\n                        }\r\n                    </select>\r\n                </div>\r\n\r\n                <button className=\"start-btn\" disabled={isRunning}\r\n                        onClick={() => startAlgorithm()}>\r\n                    Start Visualization\r\n                </button>\r\n            </div>\r\n\r\n            <div style={{display: \"flex\", justifyContent: \"center\"}}>\r\n                <p>\r\n                    <input id=\"setStart\" type=\"radio\" value={OnClickEventType.SET_START} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_START}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_START)}/>\r\n                    <label htmlFor={\"setStart\"}>Set Start</label>\r\n                </p>\r\n\r\n                <p>\r\n                    <input id=\"setFinish\" type=\"radio\" value={OnClickEventType.SET_FINISH} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_FINISH}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_FINISH)}/>\r\n                    <label htmlFor={\"setFinish\"}>Set Finish</label>\r\n                </p>\r\n\r\n                <p>\r\n                    <input id=\"setWall\" type=\"radio\" value={OnClickEventType.SET_WALL} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_WALL}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_WALL)}/>\r\n                    <label htmlFor={\"setWall\"}>Set Wall</label>\r\n                </p>\r\n\r\n                <p>\r\n                    <input id=\"removeWall\" type=\"radio\" value={OnClickEventType.REMOVE_WALL} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.REMOVE_WALL}\r\n                           onChange={() => setOnClickType(OnClickEventType.REMOVE_WALL)}/>\r\n                    <label htmlFor={\"removeWall\"}>Unset Wall</label>\r\n                </p>\r\n            </div>\r\n\r\n            <div>\r\n                <div className=\"grid__container\">\r\n                    {\r\n                        grid.map((row, rowIdx) => {\r\n                            return <div key={rowIdx} className=\"grid__container__row\">\r\n                                {row.map((cell, cellIdx) =>\r\n                                    <Cell key={cellIdx} cell={cell}\r\n                                          onMouseDownHandler={() => handleMouseDown()}\r\n                                          onMouseUpHandler={() => handleMouseUp()}\r\n                                          onMouseEnterHandler={(cell: ICell) => handleOnMouseEnter(cell)}\r\n                                          onClickHandler={(cell: ICell) => handleOnClick(cell)}\r\n                                    />)}\r\n                            </div>\r\n                        })\r\n                    }\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Grid;\r\n","import React from 'react';\r\nimport Grid from \"../components/table/grid/Grid\";\r\nimport {GridConfiguration} from \"../types/GridTypes\";\r\nimport {Dijkstra} from \"../algorithms/Dijkstra\";\r\n\r\nconst gridConfiguration: GridConfiguration = {\r\n    numColumns: 50,\r\n    numRows: 20,\r\n    algorithms: [\r\n        {\r\n            name: \"Dijkstra\",\r\n            instance: new Dijkstra()\r\n        }\r\n    ]\r\n};\r\n\r\nconst Main = () => {\r\n    return (\r\n        <div>\r\n            <Grid {...gridConfiguration} />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Main;\r\n","import React from 'react';\nimport './App.css';\nimport Main from \"./pages/main\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Main/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}