{"version":3,"sources":["types/GridTypes.ts","components/table/cell/Cell.tsx","algorithms/AbstractAlgorithm.ts","data-structures/MinHeap.ts","utils/Utils.ts","algorithms/Dijkstra.ts","components/table/grid/Grid.tsx","algorithms/AStarAlgorithm.ts","pages/main.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["OnClickEventType","getClass","cell","result","push","isStart","isFinish","isWall","join","Cell","props","useState","setReload","id","coordinate","row","col","onClick","onClickHandler","onMouseDown","onMouseDownHandler","onMouseUp","onMouseUpHandler","onMouseUpCapture","onMouseEnter","onMouseEnterHandler","onMouseLeave","rel","className","cellToNode","distance","gScore","prev","AbstractAlgorithm","finishNode","this","shortestPath","curr","reverse","MinHeap","data","length","item","reorganize","index","parentIndex","Math","floor","parentVal","pushedVal","swap","max","tmp","isEmpty","temp","pop","Error","ret","i","rightChildIndex","leftChildIndex","lowest","n","filter","md","obj1","obj2","JSON","stringify","Dijkstra","grid","startCell","endCell","visitedCellsInOrder","start","open","insert","next","removeTop","nextCell","findNeighbors","forEach","neighbor","includes","node","neighbors","INIT_START","INIT_END","computeInitialGrid","config","numRows","currRow","numColumns","Grid","setGrid","name","instance","algorithm","setAlgorithm","SET_START","onClickType","setOnClickType","setStartCell","setEndCell","isRunning","setRunning","visitedElements","setVisitedElements","isMouseDown","setMouseDown","animate","visited","visitedEl","setTimeout","currCell","el","document","getElementById","classList","add","clearBoard","remove","useEffect","handleMouseUp","window","removeEventListener","onChange","e","algorithms","parseInt","target","value","handleAlgorithmSelection","map","algo","idx","disabled","visitedCells","compute","getShortestPath","startAlgorithm","style","display","justifyContent","type","checked","htmlFor","SET_FINISH","SET_WALL","REMOVE_WALL","rowIdx","cellIdx","addEventListener","handleOnMouseEnter","handleOnClick","AStarAlgorithm","newGScore","h","abs","Infinity","gridConfiguration","Main","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"wMAkCYA,E,4ECtBNC,G,YAAW,SAACC,GACd,IAAIC,EAAS,CAAC,QAMd,OALAA,EAAOC,KACFF,EAAKG,QAAU,iBACZH,EAAKI,SAAW,kBACZJ,EAAKK,OAAS,gBAAkB,IAErCJ,EAAOK,KAAK,OAoBRC,EAjBF,SAACC,GAAqB,MAEHC,oBAAkB,GAFf,mBAEhBC,GAFgB,WAI/B,OACI,qBAAKC,GAAI,QAAUH,EAAMR,KAAKY,WAAWC,IAAM,IAAML,EAAMR,KAAKY,WAAWE,IACtEC,QAAS,kBAAMP,EAAMQ,eAAeR,EAAMR,OAC1CiB,YAAa,kBAAMT,EAAMU,sBACzBC,UAAW,kBAAMX,EAAMY,oBACvBC,iBAAkB,kBAAMb,EAAMY,oBAC9BE,aAAc,kBAAMd,EAAMe,oBAAoBf,EAAMR,OACpDwB,aAAc,kBAAMd,GAAU,SAAAe,GAAG,OAAKA,MACtCC,UAAW3B,EAASS,EAAMR,SDOhC,SAAS2B,EAAW3B,EAAa4B,EACbC,EACAC,GACvB,MAAO,CACH9B,KAAMA,EACN4B,SAAUA,EACVC,OAAQA,EACRC,KAAMA,I,SAdFhC,O,2BAAAA,I,yBAAAA,I,uBAAAA,I,8BAAAA,M,qCE5BUiC,EAAtB,WAGI,aAAyB,yBAFfC,gBAEc,EACpBC,KAAKD,WAAa,KAJ1B,8DAUQ,IAAIE,EAA6B,GAEjC,GAAID,KAAKD,WAEL,IADA,IAAIG,EAAcF,KAAKD,WACvB,UAAOG,SAAP,aAAO,EAAML,MAAM,CAAC,IAAD,EACVK,EAAKnC,KAAKG,SAAYgC,EAAKnC,KAAKI,UACjC8B,EAAahC,KAAKiC,EAAKnC,MAE3BmC,EAAOA,EAAKL,KAIpB,OAAOI,EAAaE,cAtB5B,KCIO,IAAMC,EAAb,WAGI,aAAe,yBAFfC,UAEc,EACVL,KAAKK,KAAO,GAJpB,sDAQQ,OAA4B,IAArBL,KAAKK,KAAKC,SARzB,6BAWkBC,GACVP,KAAKK,KAAKpC,KAAKsC,GACfP,KAAKQ,WAAWR,KAAKK,KAAKC,OAAS,KAb3C,iCAmBuBG,GACf,IAAIC,EAAcC,KAAKC,OAAOH,EAAQ,GAAK,EAAI,GAC3CC,EAAc,IAAGA,EAAc,GAInC,IAFA,IAAIG,EAAYb,KAAKK,KAAKK,GAAaf,SACjCmB,EAAYd,KAAKK,KAAKI,GAAOd,SAC5Bc,EAAQ,GAAKI,EAAYC,GAC5BJ,EAAcC,KAAKC,OAAOH,EAAQ,GAAK,EAAI,GAC3CT,KAAKe,KAAKN,EAAOC,GACjBD,EAAQC,EACRG,EAAYb,KAAKK,KAAKM,KAAKK,IAAIL,KAAKC,OAAOH,EAAQ,GAAK,EAAI,GAAI,IAAId,WA7BhF,2BAiCiBc,EAAeC,GACxB,IAAIO,EAAMjB,KAAKK,KAAKK,GACpBV,KAAKK,KAAKK,GAAeV,KAAKK,KAAKI,GACnCT,KAAKK,KAAKI,GAASQ,IApC3B,kCA2CQ,IAAKjB,KAAKkB,UAAW,CACjB,IAAIC,EAAOnB,KAAKK,KAAKe,MACrB,IAAKD,EAAM,MAAM,IAAIE,MAAM,gCAE3B,GAAIrB,KAAKK,KAAKC,OAAS,EAAG,OAAOa,EAEjC,IAAMG,EAAatB,KAAKK,KAAK,GAC7BL,KAAKK,KAAK,GAAKc,EAGf,IAFA,IAAII,EAAI,IAEK,CACT,IAAIC,EAA4B,GAATD,EAAI,GACvBE,EAA2B,GAATF,EAAI,GAAS,EAC/BG,EAASF,EACb,GAAIC,GAAkBzB,KAAKK,KAAKC,QAAUkB,GAAmBxB,KAAKK,KAAKC,OAAQ,MAW/E,GATImB,GAAkBzB,KAAKK,KAAKC,SAAQoB,EAASF,GAC7CA,GAAmBxB,KAAKK,KAAKC,SAAQoB,EAASD,GAG5CA,GAAkBzB,KAAKK,KAAKC,QAAakB,GAAmBxB,KAAKK,KAAKC,SACxEoB,EAAS1B,KAAKK,KAAKmB,GAAiB7B,SAAWK,KAAKK,KAAKoB,GAAgB9B,SAAW6B,EAAkBC,KAItGzB,KAAKK,KAAKkB,GAAG5B,SAAWK,KAAKK,KAAKqB,GAAQ/B,UAGvC,MAFHK,KAAKe,KAAKQ,EAAGG,GACbH,EAAIG,EAGZ,OAAOJ,EAEX,MAAM,IAAID,MAAM,gBA3ExB,+BA8EaM,GACL,OAAyF,IAAlF3B,KAAKK,KAAKuB,QAAO,SAAAC,GAAE,OCzFVC,EDyFsBD,EAAG9D,KAAKY,WCzFhBoD,EDyF4BJ,EAAE5D,KAAKY,WCxF9DqD,KAAKC,UAAUH,KAAUE,KAAKC,UAAUF,GAD5C,IAAiBD,EAAcC,KDyFgDzB,WA/EtF,KEIa4B,EAAb,kDACI,aAAe,wCADnB,oDAKYC,EAAsBC,EAAkBC,GAC5CrC,KAAKD,WAAa,KAClB,IAAIuC,EAAoC,GAElCC,EAAQ7C,EAAW0C,EAAW,EAAG,EAAG,MACtCI,EAAO,IAAIpC,EAGf,IAFAoC,EAAKC,OAAOF,IAEJC,EAAKtB,WAAW,CACpB,IAAIwB,EAAcF,EAAKG,YACnBC,EAAWF,EAAK3E,KACpB,GAAI6E,EAASzE,SAAU,CAEnB6B,KAAKD,WAAa2C,EAClB,MAICE,EAAS1E,SAAY0E,EAASxE,QAC/BkE,EAAoBrE,KAAK2E,GAGC5C,KAAK6C,cAAcH,EAAMP,GAE7CW,SAAQ,SAAAC,GACTT,EAAoBU,SAASD,EAAShF,OAAUyE,EAAKQ,SAASD,IAC/DP,EAAKC,OAAOM,MAKxB,OAAOT,IApCf,oCAuCkBW,EAAad,GACvB,IAAIe,EAA0B,GACzBvE,EAAcsE,EAAKlF,KAAnBY,WAEL,GAAIwD,EAAKxD,EAAWC,IAAM,GAAI,CAC1B,IAAM+C,EAAIQ,EAAKxD,EAAWC,IAAM,GAAGD,EAAWE,KAEzC8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGsB,EAAKtD,SAAW,EAAG,EAAGsD,IAG3D,GAAId,EAAKxD,EAAWC,IAAM,GAAI,CAC1B,IAAM+C,EAAIQ,EAAKxD,EAAWC,IAAM,GAAGD,EAAWE,KAEzC8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGsB,EAAKtD,SAAW,EAAG,EAAGsD,IAG3D,GAAId,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAAI,CAC1C,IAAM8C,EAAIQ,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAE3C8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGsB,EAAKtD,SAAW,EAAG,EAAGsD,IAG3D,GAAId,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAAI,CAC1C,IAAM8C,EAAIQ,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAE3C8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGsB,EAAKtD,SAAW,EAAG,EAAGsD,IAI3D,OAAOC,MAxEf,GAA8BpD,GCR1BqD,EAAoB,CACpBxE,WAAY,CACRC,IAAK,GACLC,IAAK,GAETX,SAAS,EACTC,UAAU,EACVC,QAAQ,GAGRgF,EAAkB,CAClBzE,WAAY,CACRC,IAAK,GACLC,IAAK,IAETX,SAAS,EACTC,UAAU,EACVC,QAAQ,GAGNiF,EAAqB,SAACC,EAA2BlB,EAAkBC,GAErE,IADA,IAAIF,EAAO,GACFvD,EAAM,EAAGA,EAAM0E,EAAOC,QAAS3E,IAAO,CAG3C,IAFA,IAAI4E,EAAmB,GAEd3E,EAAM,EAAGA,EAAMyE,EAAOG,WAAY5E,IACvC2E,EAAQvF,KAAK,CACTC,QAASW,IAAQuD,EAAUzD,WAAWE,KAAOD,IAAQwD,EAAUzD,WAAWC,IAC1ET,SAAUU,IAAQwD,EAAQ1D,WAAWE,KAAOD,IAAQyD,EAAQ1D,WAAWC,IACvER,QAAQ,EACRO,WAAY,CACRC,IAAKA,EACLC,IAAKA,KAIjBsD,EAAKlE,KAAKuF,GAEd,OAAOrB,GAmMIuB,EAhMF,SAACJ,GAA+B,IAAD,EAChB9E,mBAAyB,CAAC,KADV,mBACjC2D,EADiC,KAC3BwB,EAD2B,OAENnF,mBAAoB,CAACoF,KAAM,GAAIC,SAAU,IAAI3B,IAFvC,mBAEjC4B,EAFiC,KAEtBC,EAFsB,OAGFvF,mBAA2BX,EAAiBmG,WAH1C,mBAGjCC,EAHiC,KAGpBC,EAHoB,OAIN1F,mBAAgB2E,GAJV,mBAIjCf,EAJiC,KAItB+B,EAJsB,OAKV3F,mBAAgB4E,GALN,mBAKjCf,EALiC,KAKxB+B,EALwB,OAMR5F,oBAAS,GAND,mBAMjC6F,EANiC,KAMtBC,EANsB,OAOM9F,mBAAyB,IAP/B,mBAOjC+F,EAPiC,KAOhBC,EAPgB,OAQJhG,oBAAkB,GARd,mBAQjCiG,EARiC,KAQpBC,EARoB,KA0ClCC,EAAU,SAACC,EAAuB3E,GAEpC,IADA,IAAI4E,EAA4B,GADmC,WAE1DtD,GACLuD,YAAW,WACP,IAAIC,EAAWH,EAAQrD,GACnByD,EAAKC,SAASC,eAAe,QAAUH,EAASpG,WAAWC,IAAM,IAAMmG,EAASpG,WAAWE,KAC3FmG,IACAA,EAAGG,UAAUC,IAAI,oBACjBP,EAAU5G,KAAK+G,MAEpB,GAAKzD,IARHA,EAAI,EAAGA,EAAIqD,EAAQtE,OAAQiB,IAAM,EAAjCA,GAYTuD,YAAW,WAEP,IAFc,IAAD,WAEJvD,GACLuD,YAAW,WACP,IAAIC,EAAW9E,EAAasB,GACxByD,EAAKC,SAASC,eAAe,QAAUH,EAASpG,WAAWC,IAAM,IAAMmG,EAASpG,WAAWE,KAC3FmG,GACAA,EAAGG,UAAUC,IAAI,4BAEtB,GAAK7D,IAPHA,EAAI,EAAGA,EAAItB,EAAaK,OAAQiB,IAAM,EAAtCA,GAUTuD,YAAW,WACPN,EAAmBK,GACnBP,GAAW,KACZ,GAAKrE,EAAaK,UACtB,GAAKsE,EAAQtE,SAGd+E,EAAa,WAAO,IAAD,gBACNd,GADM,IACrB,2BAAgC,CAAC,IAAxBS,EAAuB,QAC5BA,EAAGG,UAAUG,OAAO,oBACpBN,EAAGG,UAAUG,OAAO,2BAHH,gCAYzBC,qBAAU,WACN5B,EAAQN,EAAmBC,EAAQlB,EAAWC,MAC/C,CAACiB,EAAQlB,EAAWC,IAEvB,IAUMmD,EAAgB,SAAhBA,IACFd,GAAa,GACbe,OAAOC,oBAAoB,UAAWF,GAAe,IAazD,OACI,gCACI,sBAAK/F,UAAU,sBAAf,UACI,sDACA,qBAAKA,UAAU,gBAAf,SACI,wBAAQkG,SAAU,SAACC,GAAD,OA9BD,SAACA,GAC9B7B,EAAaT,EAAOuC,WAAWC,SAASF,EAAEG,OAAOC,SA6BZC,CAAyBL,IAAlD,SAEQtC,EAAOuC,WAAWK,KAAI,SAACC,EAAMC,GACzB,OAAO,wBAAkBJ,MAAOI,EAAzB,SAA+BD,EAAKvC,MAAvBwC,UAMpC,wBAAQ3G,UAAU,YAAY4G,SAAUhC,EAChCvF,QAAS,kBAjGN,WACnBuG,IACAf,GAAW,GACX,IAAMgC,EAAexC,EAAUD,SAAS0C,QAAQpE,EAAMC,EAAWC,GAC3DpC,EAAe6D,EAAUD,SAAS2C,kBACxC7B,EAAQ2B,EAAcrG,GA4FSwG,IADvB,iCAKA,wBAAQhH,UAAU,YAAY4G,SAAUhC,EAChCvF,QAAS,kBArDzBuG,SACA1B,EAAQN,EAAmBC,EAAQlB,EAAWC,KAmDtC,sBAMJ,sBAAKqE,MAAO,CAACC,QAAS,OAAQC,eAAgB,UAA9C,UACI,8BACI,uBAAOlI,GAAG,WAAWmI,KAAK,QAAQb,MAAOnI,EAAiBmG,UAAWJ,KAAK,mBACnEkD,QAAS7C,IAAgBpG,EAAiBmG,UAC1C2B,SAAU,kBAAMzB,EAAerG,EAAiBmG,cACvD,uBAAO+C,QAAS,WAAhB,0BAGJ,8BACI,uBAAOrI,GAAG,YAAYmI,KAAK,QAAQb,MAAOnI,EAAiBmJ,WAAYpD,KAAK,mBACrEkD,QAAS7C,IAAgBpG,EAAiBmJ,WAC1CrB,SAAU,kBAAMzB,EAAerG,EAAiBmJ,eACvD,uBAAOD,QAAS,YAAhB,2BAGJ,8BACI,uBAAOrI,GAAG,UAAUmI,KAAK,QAAQb,MAAOnI,EAAiBoJ,SAAUrD,KAAK,mBACjEkD,QAAS7C,IAAgBpG,EAAiBoJ,SAC1CtB,SAAU,kBAAMzB,EAAerG,EAAiBoJ,aACvD,uBAAOF,QAAS,UAAhB,yBAGJ,8BACI,uBAAOrI,GAAG,aAAamI,KAAK,QAAQb,MAAOnI,EAAiBqJ,YAAatD,KAAK,mBACvEkD,QAAS7C,IAAgBpG,EAAiBqJ,YAC1CvB,SAAU,kBAAMzB,EAAerG,EAAiBqJ,gBACvD,uBAAOH,QAAS,aAAhB,8BAIR,8BACI,qBAAKtH,UAAU,kBAAf,SAEQ0C,EAAK+D,KAAI,SAACtH,EAAKuI,GACX,OAAO,qBAAkB1H,UAAU,uBAA5B,SACFb,EAAIsH,KAAI,SAACnI,EAAMqJ,GAAP,OACL,cAAC,EAAD,CAAoBrJ,KAAMA,EACpBkB,mBAAoB,kBAlFtDyF,GAAa,GACbe,OAAO4B,iBAAiB,UAAW7B,GAAe,QAClDH,KAiFkClG,iBAAkB,kBAAMqG,KACxBlG,oBAAqB,SAACvB,GAAD,OA1EhC,SAACA,GACpB0G,IAAgBJ,IACZJ,IAAgBpG,EAAiBoJ,SACjClJ,EAAKK,QAAS,EACP6F,IAAgBpG,EAAiBqJ,cACxCnJ,EAAKK,QAAS,IAqEkDkJ,CAAmBvJ,IACzDgB,eAAgB,SAAChB,GAAD,OA3KhC,SAACA,GACnB,IAAIsG,EAAJ,CAEA,OAAQJ,GACJ,KAAKpG,EAAiBmG,UAClB5B,EAAUlE,SAAU,EACpBH,EAAKG,SAAU,EACfiG,EAAapG,GACb,MACJ,KAAKF,EAAiBmJ,WAClB3E,EAAQlE,UAAW,EACnBJ,EAAKI,UAAW,EAChBiG,EAAWrG,GACX,MACJ,KAAKF,EAAiBoJ,SAClBlJ,EAAKK,QAAS,EACd,MACJ,KAAKP,EAAiBqJ,YAClBnJ,EAAKK,QAAS,EAGtBiH,KAsJmEkC,CAAcxJ,KAJ1CqJ,OAFFD,cC9MhCK,EAAb,kDACI,aAAe,wCADnB,oDAKYrF,EAAsBC,EAAkBC,GAA+B,IAAD,OAC1ErC,KAAKD,WAAa,KAClB,IAAIuC,EAAoC,GAElCC,EAAQ7C,EAAW0C,EAAW,EAAG,EAAG,MACtCI,EAAO,IAAIpC,EACfoC,EAAKC,OAAOF,GAEZ,IAR0E,iBAStE,IAAIrC,EAAcsC,EAAKG,YACnBoC,EAAW7E,EAAKnC,KACpB,GAAIgH,EAAS5G,SAGT,OADA,EAAK4B,WAAaG,EAClB,QAGC6E,EAAS7G,SAAY6G,EAAS3G,QAC/BkE,EAAoBrE,KAAK8G,GAGC,EAAKlC,cAAc3C,EAAMiC,GAC7CW,SAAQ,SAAAC,GACd,IAAI0E,EAAYvH,EAAKN,OAAS,EAE1B6H,EAAY1E,EAASnD,SACrBmD,EAASnD,OAAS6H,EAClB1E,EAASpD,SAAW8H,EAAY,EAAKC,EAAE3E,EAAShF,KAAMsE,GAEjDC,EAAoBU,SAASD,EAAShF,OAAUyE,EAAKQ,SAASD,IAC/DP,EAAKC,OAAOM,SAtBpBP,EAAKtB,WAAW,kBAMhB,MAqBR,OAAOoB,IAxCf,wBA8CcvE,EAAasE,GAGnB,OAFgB1B,KAAKgH,IAAI5J,EAAKY,WAAWC,IAAMyD,EAAQ1D,WAAWC,KAClD+B,KAAKgH,IAAI5J,EAAKY,WAAWE,IAAMwD,EAAQ1D,WAAWE,OAhD1E,oCAoDkBoE,EAAad,GACvB,IAAIe,EAA0B,GACzBvE,EAAcsE,EAAKlF,KAAnBY,WAEL,GAAIwD,EAAKxD,EAAWC,IAAM,GAAI,CAC1B,IAAM+C,EAAIQ,EAAKxD,EAAWC,IAAM,GAAGD,EAAWE,KAEzC8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGiG,IAAUA,IAAU3E,IAGzD,GAAId,EAAKxD,EAAWC,IAAM,GAAI,CAC1B,IAAM+C,EAAIQ,EAAKxD,EAAWC,IAAM,GAAGD,EAAWE,KAEzC8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGiG,IAAUA,IAAU3E,IAGzD,GAAId,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAAI,CAC1C,IAAM8C,EAAIQ,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAE3C8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGiG,IAAUA,IAAU3E,IAGzD,GAAId,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAAI,CAC1C,IAAM8C,EAAIQ,EAAKxD,EAAWC,KAAKD,EAAWE,IAAM,GAE3C8C,EAAEvD,QACH8E,EAAUjF,KAAKyB,EAAWiC,EAAGiG,IAAUA,IAAU3E,IAIzD,OAAOC,MArFf,GAAoCpD,GCV9B+H,EAAuC,CACzCpE,WAAY,GACZF,QAAS,GACTsC,WAAY,CACR,CACIjC,KAAM,WACNC,SAAU,IAAI3B,GAElB,CACI0B,KAAM,YACNC,SAAU,IAAI2D,KAaXM,EARF,WACT,OACI,8BACI,cAAC,EAAD,eAAUD,OCZPE,MARf,WACE,OACE,qBAAKtI,UAAU,MAAf,SACE,cAAC,EAAD,OCOSuI,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEF1D,SAASC,eAAe,SAM1B8C,M","file":"static/js/main.8e844163.chunk.js","sourcesContent":["import {AbstractAlgorithm} from \"../algorithms/AbstractAlgorithm\";\r\n\r\nexport interface GridConfiguration {\r\n    numColumns: number,\r\n    numRows: number,\r\n    algorithms: Array<Algorithm>\r\n}\r\n\r\nexport interface ICoordinate {\r\n    row: number,\r\n    col: number\r\n}\r\n\r\nexport interface ICell {\r\n    coordinate: ICoordinate,\r\n    isStart: boolean,\r\n    isFinish: boolean,\r\n    isWall: boolean\r\n}\r\n\r\nexport interface INode {\r\n    cell: ICell,\r\n    distance: number,\r\n    prev: INode | null,\r\n\r\n    // for A* algorithm\r\n    gScore: number,\r\n}\r\n\r\nexport interface Algorithm {\r\n    name: String,\r\n    instance: AbstractAlgorithm\r\n}\r\n\r\nexport enum OnClickEventType {\r\n    SET_FINISH,\r\n    SET_START,\r\n    SET_WALL,\r\n    REMOVE_WALL\r\n}\r\n\r\nexport function cellToNode(cell: ICell, distance: number,\r\n                           gScore: number,\r\n                           prev: INode | null): INode {\r\n    return {\r\n        cell: cell,\r\n        distance: distance,\r\n        gScore: gScore,\r\n        prev: prev\r\n    }\r\n}\r\n","import React, {useState} from 'react';\r\nimport \"./Cell.css\"\r\nimport {ICell} from \"../../../types/GridTypes\";\r\n\r\ninterface CellProps {\r\n    cell: ICell,\r\n    onClickHandler: Function,\r\n    onMouseDownHandler: Function,\r\n    onMouseUpHandler: Function,\r\n    onMouseEnterHandler: Function\r\n}\r\n\r\nconst getClass = (cell: ICell) => {\r\n    let result = [\"cell\"];\r\n    result.push(\r\n        (cell.isStart ? \"cell--is-start\" :\r\n            cell.isFinish ? \"cell--is-finish\" :\r\n                cell.isWall ? \"cell--is-wall\" : \"\"));\r\n\r\n    return result.join(\" \");\r\n};\r\n\r\nconst Cell = (props: CellProps) => {\r\n    // to enforce state reload...\r\n    const [reload, setReload] = useState<boolean>(false);\r\n\r\n    return (\r\n        <div id={\"cell-\" + props.cell.coordinate.row + \"-\" + props.cell.coordinate.col}\r\n             onClick={() => props.onClickHandler(props.cell)}\r\n             onMouseDown={() => props.onMouseDownHandler()}\r\n             onMouseUp={() => props.onMouseUpHandler()}\r\n             onMouseUpCapture={() => props.onMouseUpHandler()}\r\n             onMouseEnter={() => props.onMouseEnterHandler(props.cell)}\r\n             onMouseLeave={() => setReload(rel => !rel)}\r\n             className={getClass(props.cell)}\r\n        />\r\n    );\r\n};\r\n\r\nexport default Cell;\r\n","import {ICell, INode} from \"../types/GridTypes\";\r\n\r\ninterface DistanceFunc {\r\n    (node: INode): number\r\n}\r\n\r\nexport abstract class AbstractAlgorithm {\r\n    protected finishNode: INode | null;\r\n\r\n    protected constructor() {\r\n        this.finishNode = null;\r\n    }\r\n\r\n    abstract compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell>;\r\n\r\n    public getShortestPath(): Array<ICell> {\r\n        let shortestPath: Array<ICell> = [];\r\n\r\n        if (this.finishNode) {\r\n            let curr: INode = this.finishNode\r\n            while (curr?.prev) {\r\n                if (!curr.cell.isStart && !curr.cell.isFinish) {\r\n                    shortestPath.push(curr.cell);\r\n                }\r\n                curr = curr.prev;\r\n            }\r\n        }\r\n\r\n        return shortestPath.reverse();\r\n    }\r\n}\r\n","/**\r\n * Binary heap (min-heap) used for dijkstra algorithm\r\n * Reference: https://medium.com/dev-genius/how-to-implement-a-binary-heap-javascript-d3a0c54112fa\r\n *\r\n * Insert: O(logn)\r\n * GetMin: O(logn)\r\n */\r\nimport {INode} from \"../types/GridTypes\";\r\nimport {isEqual} from \"../utils/Utils\";\r\n\r\nexport class MinHeap {\r\n    data: Array<INode>;\r\n\r\n    constructor() {\r\n        this.data = []\r\n    }\r\n\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n\r\n    public insert(item: INode): void {\r\n        this.data.push(item);\r\n        this.reorganize(this.data.length - 1);\r\n    }\r\n\r\n    /**\r\n     * Reorganizes values in heap\r\n     */\r\n    private reorganize(index: number) {\r\n        let parentIndex = Math.floor((index + 1) / 2 - 1);\r\n        if (parentIndex < 0) parentIndex = 0;\r\n\r\n        let parentVal = this.data[parentIndex].distance;\r\n        const pushedVal = this.data[index].distance;\r\n        while (index > 0 && parentVal > pushedVal) {\r\n            parentIndex = Math.floor((index + 1) / 2 - 1);\r\n            this.swap(index, parentIndex);\r\n            index = parentIndex;\r\n            parentVal = this.data[Math.max(Math.floor((index + 1) / 2 - 1), 0)].distance;\r\n        }\r\n    }\r\n\r\n    private swap(index: number, parentIndex: number) {\r\n        let tmp = this.data[parentIndex]\r\n        this.data[parentIndex] = this.data[index];\r\n        this.data[index] = tmp;\r\n    }\r\n\r\n    /**\r\n     * Removes top element from heap\r\n     */\r\n    public removeTop(): INode {\r\n        if (!this.isEmpty()) {\r\n            let temp = this.data.pop();\r\n            if (!temp) throw new Error(\"Undefined heap element found\")\r\n\r\n            if (this.data.length < 1) return temp;\r\n\r\n            const ret: INode = this.data[0]; // What we will return\r\n            this.data[0] = temp; // Place last element in array at front\r\n            let i = 0; // We adjust heap from top to down\r\n\r\n            while (true) {\r\n                let rightChildIndex = (i + 1) * 2;\r\n                let leftChildIndex = (i + 1) * 2 - 1;\r\n                let lowest = rightChildIndex;\r\n                if (leftChildIndex >= this.data.length && rightChildIndex >= this.data.length) break;\r\n\r\n                if (leftChildIndex >= this.data.length) lowest = rightChildIndex;\r\n                if (rightChildIndex >= this.data.length) lowest = leftChildIndex;\r\n\r\n                // Find the smallest child\r\n                if (!(leftChildIndex >= this.data.length) && !(rightChildIndex >= this.data.length)) {\r\n                    lowest = this.data[rightChildIndex].distance < this.data[leftChildIndex].distance ? rightChildIndex : leftChildIndex;\r\n                }\r\n\r\n                // If the parent is greater than the smallest child: swap\r\n                if (this.data[i].distance > this.data[lowest].distance) {\r\n                    this.swap(i, lowest);\r\n                    i = lowest;\r\n                } else break;\r\n            }\r\n            return ret;\r\n        }\r\n        throw new Error(\"Empty Heap\");\r\n    }\r\n\r\n    includes(n: INode) {\r\n        return this.data.filter(md => isEqual(md.cell.coordinate, n.cell.coordinate)).length !== 0;\r\n    }\r\n}\r\n","export function isEqual(obj1: Object, obj2: Object): boolean {\r\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\r\n}\r\n","import {AbstractAlgorithm} from \"./AbstractAlgorithm\";\r\nimport {cellToNode, ICell, INode} from \"../types/GridTypes\";\r\nimport {MinHeap} from \"../data-structures/MinHeap\";\r\n\r\n/**\r\n * Dijkstra is a Greedy algorithm\r\n *\r\n * Steps:\r\n * 1. Initialize start node with distance 0\r\n * 2. Get node with minimum distance from heap and add as visited\r\n * 3. getNeighbors from minimum distance node\r\n * 4. Remove current top node from heap and add Neighbor nodes to heap\r\n * 5. Repeat from 2 until endCell found\r\n */\r\nexport class Dijkstra extends AbstractAlgorithm {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell> {\r\n        this.finishNode = null;\r\n        let visitedCellsInOrder: Array<ICell> = [];\r\n\r\n        const start = cellToNode(startCell, 0, 0, null);\r\n        let open = new MinHeap();\r\n        open.insert(start);\r\n\r\n        while (!open.isEmpty()) {\r\n            let next: INode = open.removeTop();\r\n            let nextCell = next.cell;\r\n            if (nextCell.isFinish) {\r\n                // end here because end cell found!\r\n                this.finishNode = next;\r\n                break\r\n            }\r\n\r\n            // mark cell as visited\r\n            if (!nextCell.isStart && !nextCell.isWall) {\r\n                visitedCellsInOrder.push(nextCell);\r\n            }\r\n\r\n            let neighbors: Array<INode> = this.findNeighbors(next, grid);\r\n\r\n            neighbors.forEach(neighbor => {\r\n                if (!visitedCellsInOrder.includes(neighbor.cell) && !open.includes(neighbor)) {\r\n                    open.insert(neighbor);\r\n                }\r\n            });\r\n        }\r\n\r\n        return visitedCellsInOrder;\r\n    }\r\n\r\n    findNeighbors(node: INode, grid: Array<ICell[]>) {\r\n        let neighbors: Array<INode> = [];\r\n        let {coordinate} = node.cell;\r\n\r\n        if (grid[coordinate.row + 1]) {\r\n            const n = grid[coordinate.row + 1][coordinate.col];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, 0, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row - 1]) {\r\n            const n = grid[coordinate.row - 1][coordinate.col];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, 0, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row][coordinate.col + 1]) {\r\n            const n = grid[coordinate.row][coordinate.col + 1];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, 0, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row][coordinate.col - 1]) {\r\n            const n = grid[coordinate.row][coordinate.col - 1];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, node.distance + 1, 0, node))\r\n            }\r\n        }\r\n\r\n        return neighbors;\r\n    }\r\n}\r\n","import React, {useEffect, useState} from 'react';\r\nimport \"./Grid.css\"\r\nimport Cell from \"../cell/Cell\";\r\nimport {Algorithm, GridConfiguration, ICell, OnClickEventType} from \"../../../types/GridTypes\";\r\nimport {Dijkstra} from \"../../../algorithms/Dijkstra\";\r\n\r\nlet INIT_START: ICell = {\r\n    coordinate: {\r\n        row: 10,\r\n        col: 5\r\n    },\r\n    isStart: true,\r\n    isFinish: false,\r\n    isWall: false\r\n};\r\n\r\nlet INIT_END: ICell = {\r\n    coordinate: {\r\n        row: 14,\r\n        col: 15\r\n    },\r\n    isStart: false,\r\n    isFinish: true,\r\n    isWall: false\r\n};\r\n\r\nconst computeInitialGrid = (config: GridConfiguration, startCell: ICell, endCell: ICell): Array<ICell[]> => {\r\n    let grid = []\r\n    for (let row = 0; row < config.numRows; row++) {\r\n        let currRow: ICell[] = [];\r\n\r\n        for (let col = 0; col < config.numColumns; col++) {\r\n            currRow.push({\r\n                isStart: col === startCell.coordinate.col && row === startCell.coordinate.row,\r\n                isFinish: col === endCell.coordinate.col && row === endCell.coordinate.row,\r\n                isWall: false,\r\n                coordinate: {\r\n                    row: row,\r\n                    col: col\r\n                },\r\n            })\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst Grid = (config: GridConfiguration) => {\r\n    const [grid, setGrid] = useState<Array<ICell[]>>([[]]);\r\n    const [algorithm, setAlgorithm] = useState<Algorithm>({name: \"\", instance: new Dijkstra()});\r\n    const [onClickType, setOnClickType] = useState<OnClickEventType>(OnClickEventType.SET_START);\r\n    const [startCell, setStartCell] = useState<ICell>(INIT_START);\r\n    const [endCell, setEndCell] = useState<ICell>(INIT_END);\r\n    const [isRunning, setRunning] = useState(false);\r\n    const [visitedElements, setVisitedElements] = useState<Array<Element>>([]);\r\n    const [isMouseDown, setMouseDown] = useState<boolean>(false);\r\n\r\n    const handleOnClick = (cell: ICell) => {\r\n        if (isRunning) return\r\n\r\n        switch (onClickType) {\r\n            case OnClickEventType.SET_START:\r\n                startCell.isStart = false;\r\n                cell.isStart = true\r\n                setStartCell(cell);\r\n                break;\r\n            case OnClickEventType.SET_FINISH:\r\n                endCell.isFinish = false;\r\n                cell.isFinish = true\r\n                setEndCell(cell);\r\n                break;\r\n            case OnClickEventType.SET_WALL:\r\n                cell.isWall = true;\r\n                break;\r\n            case OnClickEventType.REMOVE_WALL:\r\n                cell.isWall = false;\r\n                break;\r\n        }\r\n        clearBoard();\r\n    };\r\n\r\n    const startAlgorithm = () => {\r\n        clearBoard();\r\n        setRunning(true)\r\n        const visitedCells = algorithm.instance.compute(grid, startCell, endCell);\r\n        const shortestPath = algorithm.instance.getShortestPath();\r\n        animate(visitedCells, shortestPath);\r\n    }\r\n\r\n    const animate = (visited: Array<ICell>, shortestPath: Array<ICell>) => {\r\n        let visitedEl: Array<Element> = []\r\n        for (let i = 0; i < visited.length; i++) {\r\n            setTimeout(() => {\r\n                let currCell = visited[i]\r\n                let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                if (el) {\r\n                    el.classList.add(\"cell--is-visited\");\r\n                    visitedEl.push(el)\r\n                }\r\n            }, 10 * i)\r\n        }\r\n\r\n        // show shortest path after visited nodes are visualized\r\n        setTimeout(() => {\r\n            // animate shortest path\r\n            for (let i = 0; i < shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    let currCell = shortestPath[i]\r\n                    let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                    if (el) {\r\n                        el.classList.add(\"cell--is-shortest-path\");\r\n                    }\r\n                }, 30 * i)\r\n            }\r\n\r\n            setTimeout(() => {\r\n                setVisitedElements(visitedEl);\r\n                setRunning(false)\r\n            }, 10 * shortestPath.length)\r\n        }, 10 * visited.length)\r\n    }\r\n\r\n    const clearBoard = () => {\r\n        for (let el of visitedElements) {\r\n            el.classList.remove(\"cell--is-visited\")\r\n            el.classList.remove(\"cell--is-shortest-path\")\r\n        }\r\n    }\r\n\r\n    const clearAll = () => {\r\n        clearBoard();\r\n        setGrid(computeInitialGrid(config, startCell, endCell))\r\n    }\r\n\r\n    useEffect(() => {\r\n        setGrid(computeInitialGrid(config, startCell, endCell));\r\n    }, [config, startCell, endCell])\r\n\r\n    const handleAlgorithmSelection = (e: React.ChangeEvent<HTMLSelectElement>) => {\r\n        setAlgorithm(config.algorithms[parseInt(e.target.value)])\r\n    }\r\n\r\n    const handleMouseDown = () => {\r\n        setMouseDown(true);\r\n        window.addEventListener('mouseup', handleMouseUp, true);\r\n        clearBoard();\r\n    }\r\n\r\n    const handleMouseUp = () => {\r\n        setMouseDown(false);\r\n        window.removeEventListener('mouseup', handleMouseUp, true);\r\n    }\r\n\r\n    const handleOnMouseEnter = (cell: ICell) => {\r\n        if (isMouseDown && !isRunning) {\r\n            if (onClickType === OnClickEventType.SET_WALL) {\r\n                cell.isWall = true\r\n            } else if (onClickType === OnClickEventType.REMOVE_WALL) {\r\n                cell.isWall = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <div className=\"algorithm-selection\">\r\n                <label>Select Algorithm:</label>\r\n                <div className=\"custom-select\">\r\n                    <select onChange={(e) => handleAlgorithmSelection(e)}>\r\n                        {\r\n                            config.algorithms.map((algo, idx) => {\r\n                                return <option key={idx} value={idx}>{algo.name}</option>\r\n                            })\r\n                        }\r\n                    </select>\r\n                </div>\r\n\r\n                <button className=\"start-btn\" disabled={isRunning}\r\n                        onClick={() => startAlgorithm()}>\r\n                    Start Visualization\r\n                </button>\r\n\r\n                <button className=\"start-btn\" disabled={isRunning}\r\n                        onClick={() => clearAll()}>\r\n                    Clear\r\n                </button>\r\n            </div>\r\n\r\n            <div style={{display: \"flex\", justifyContent: \"center\"}}>\r\n                <p>\r\n                    <input id=\"setStart\" type=\"radio\" value={OnClickEventType.SET_START} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_START}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_START)}/>\r\n                    <label htmlFor={\"setStart\"}>Set Start</label>\r\n                </p>\r\n\r\n                <p>\r\n                    <input id=\"setFinish\" type=\"radio\" value={OnClickEventType.SET_FINISH} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_FINISH}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_FINISH)}/>\r\n                    <label htmlFor={\"setFinish\"}>Set Finish</label>\r\n                </p>\r\n\r\n                <p>\r\n                    <input id=\"setWall\" type=\"radio\" value={OnClickEventType.SET_WALL} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_WALL}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_WALL)}/>\r\n                    <label htmlFor={\"setWall\"}>Set Wall</label>\r\n                </p>\r\n\r\n                <p>\r\n                    <input id=\"removeWall\" type=\"radio\" value={OnClickEventType.REMOVE_WALL} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.REMOVE_WALL}\r\n                           onChange={() => setOnClickType(OnClickEventType.REMOVE_WALL)}/>\r\n                    <label htmlFor={\"removeWall\"}>Unset Wall</label>\r\n                </p>\r\n            </div>\r\n\r\n            <div>\r\n                <div className=\"grid__container\">\r\n                    {\r\n                        grid.map((row, rowIdx) => {\r\n                            return <div key={rowIdx} className=\"grid__container__row\">\r\n                                {row.map((cell, cellIdx) =>\r\n                                    <Cell key={cellIdx} cell={cell}\r\n                                          onMouseDownHandler={() => handleMouseDown()}\r\n                                          onMouseUpHandler={() => handleMouseUp()}\r\n                                          onMouseEnterHandler={(cell: ICell) => handleOnMouseEnter(cell)}\r\n                                          onClickHandler={(cell: ICell) => handleOnClick(cell)}\r\n                                    />)}\r\n                            </div>\r\n                        })\r\n                    }\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Grid;\r\n","import {AbstractAlgorithm} from \"./AbstractAlgorithm\";\r\nimport {cellToNode, ICell, INode} from \"../types/GridTypes\";\r\nimport {MinHeap} from \"../data-structures/MinHeap\";\r\n\r\n/**\r\n * A* is an informed search algorithm (uses heuristic)\r\n *\r\n * A* is more enhanced than Dijkstra as it utilizes an heuristic function h(n) which estimates\r\n * how close a state is to the goal.\r\n *\r\n * The path selection is based on the cost of the path which is:\r\n * f(n) = g(n) + h(n)\r\n *\r\n * where n is the next node on the path, g(n) is the cost of the path from the start node to n,\r\n * and h(n) is a heuristic function that estimates the cost of the cheapest path from n to the goal.\r\n */\r\nexport class AStarAlgorithm extends AbstractAlgorithm {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell> {\r\n        this.finishNode = null;\r\n        let visitedCellsInOrder: Array<ICell> = [];\r\n\r\n        const start = cellToNode(startCell, 0, 0, null);\r\n        let open = new MinHeap();\r\n        open.insert(start);\r\n\r\n        while (!open.isEmpty()) {\r\n            let curr: INode = open.removeTop();\r\n            let currCell = curr.cell;\r\n            if (currCell.isFinish) {\r\n                // end here because end cell found!\r\n                this.finishNode = curr;\r\n                break\r\n            }\r\n\r\n            if (!currCell.isStart && !currCell.isWall) {\r\n                visitedCellsInOrder.push(currCell);\r\n            }\r\n\r\n            let neighbors: Array<INode> = this.findNeighbors(curr, grid);\r\n            neighbors.forEach(neighbor => {\r\n                let newGScore = curr.gScore + 1;\r\n\r\n                if (newGScore < neighbor.gScore) {\r\n                    neighbor.gScore = newGScore;\r\n                    neighbor.distance = newGScore + this.h(neighbor.cell, endCell);\r\n\r\n                    if (!visitedCellsInOrder.includes(neighbor.cell) && !open.includes(neighbor)) {\r\n                        open.insert(neighbor);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return visitedCellsInOrder;\r\n    }\r\n\r\n    /**\r\n     * We use as heuristic function h(n) the 'Manhattan Distance'\r\n     */\r\n    private h(cell: ICell, endCell: ICell): number {\r\n        const rowDist = Math.abs(cell.coordinate.row - endCell.coordinate.row);\r\n        const colDist = Math.abs(cell.coordinate.col - endCell.coordinate.col);\r\n        return rowDist + colDist;\r\n    }\r\n\r\n    findNeighbors(node: INode, grid: Array<ICell[]>) {\r\n        let neighbors: Array<INode> = [];\r\n        let {coordinate} = node.cell;\r\n\r\n        if (grid[coordinate.row + 1]) {\r\n            const n = grid[coordinate.row + 1][coordinate.col];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, Infinity, Infinity, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row - 1]) {\r\n            const n = grid[coordinate.row - 1][coordinate.col];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, Infinity, Infinity, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row][coordinate.col + 1]) {\r\n            const n = grid[coordinate.row][coordinate.col + 1];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, Infinity, Infinity, node))\r\n            }\r\n        }\r\n        if (grid[coordinate.row][coordinate.col - 1]) {\r\n            const n = grid[coordinate.row][coordinate.col - 1];\r\n\r\n            if (!n.isWall) {\r\n                neighbors.push(cellToNode(n, Infinity, Infinity, node))\r\n            }\r\n        }\r\n\r\n        return neighbors;\r\n    }\r\n}\r\n","import React from 'react';\r\nimport Grid from \"../components/table/grid/Grid\";\r\nimport {GridConfiguration} from \"../types/GridTypes\";\r\nimport {Dijkstra} from \"../algorithms/Dijkstra\";\r\nimport {AStarAlgorithm} from \"../algorithms/AStarAlgorithm\";\r\n\r\nconst gridConfiguration: GridConfiguration = {\r\n    numColumns: 50,\r\n    numRows: 20,\r\n    algorithms: [\r\n        {\r\n            name: \"Dijkstra\",\r\n            instance: new Dijkstra()\r\n        },\r\n        {\r\n            name: \"A* Search\",\r\n            instance: new AStarAlgorithm()\r\n        }\r\n    ]\r\n};\r\n\r\nconst Main = () => {\r\n    return (\r\n        <div>\r\n            <Grid {...gridConfiguration} />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Main;\r\n","import React from 'react';\nimport './App.css';\nimport Main from \"./pages/main\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Main/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}