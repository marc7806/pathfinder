{"version":3,"sources":["types/GridTypes.ts","components/table/cell/Cell.tsx","algorithms/AbstractAlgorithm.ts","data-structures/MinHeap.ts","utils/Utils.ts","algorithms/Dijkstra.ts","components/table/grid/Grid.tsx","pages/main.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["OnClickEventType","getClass","cell","result","push","isStart","isFinish","join","Cell","props","id","coordinate","row","col","onClick","onClickHandler","className","cellToNode","distance","prev","AbstractAlgorithm","finishNode","this","MinHeap","data","item","reorganize","length","index","parentIndex","Math","floor","parentVal","pushedVal","swap","max","tmp","pop","ret","temp","i","rightChildIndex","leftChildIndex","lowest","isEqual","obj1","obj2","JSON","stringify","Dijkstra","grid","startCell","endCell","visitedCellsInOrder","start","minHeap","insert","isFinished","curr","removeTop","console","log","findNeighbors","forEach","n","includes","filter","md","node","neighbors","shortestPath","reverse","INIT_START","INIT_END","Grid","config","useState","setGrid","name","instance","algorithm","setAlgorithm","SET_START","onClickType","setOnClickType","setStartCell","setEndCell","isRunning","setRunning","visitedElements","setVisitedElements","animate","visited","visitedEl","setTimeout","currCell","el","document","getElementById","classList","add","clearBoard","remove","useEffect","numRows","currRow","numColumns","computeInitialGrid","onChange","e","algorithms","parseInt","target","value","handleAlgorithmSelection","map","algo","idx","disabled","visitedCells","compute","getShortestPath","startAlgorithm","style","display","justifyContent","type","checked","htmlFor","SET_FINISH","rowIdx","cellIdx","handleOnClick","gridConfiguration","Main","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.348dfafd.chunk.js","sourcesContent":["import {AbstractAlgorithm} from \"../algorithms/AbstractAlgorithm\";\r\n\r\nexport interface GridConfiguration {\r\n    numColumns: number,\r\n    numRows: number,\r\n    algorithms: Array<Algorithm>\r\n}\r\n\r\nexport interface ICoordinate {\r\n    row: number,\r\n    col: number\r\n}\r\n\r\nexport interface ICell {\r\n    coordinate: ICoordinate,\r\n    isStart: boolean,\r\n    isFinish: boolean\r\n}\r\n\r\nexport interface INode {\r\n    cell: ICell,\r\n    distance: number,\r\n    prev: INode | null\r\n}\r\n\r\nexport interface Algorithm {\r\n    name: String,\r\n    instance: AbstractAlgorithm\r\n}\r\n\r\nexport enum OnClickEventType {\r\n    SET_FINISH,\r\n    SET_START\r\n}\r\n\r\nexport function cellToNode(cell: ICell, distance: number, prev: INode): INode {\r\n    return {\r\n        cell: cell,\r\n        distance: distance,\r\n        prev: prev\r\n    }\r\n}\r\n","import React from 'react';\r\nimport \"./Cell.css\"\r\nimport {ICell} from \"../../../types/GridTypes\";\r\n\r\ninterface CellProps {\r\n    cell: ICell,\r\n    onClickHandler: Function\r\n}\r\n\r\nconst getClass = (cell: ICell) => {\r\n    let result = [\"cell\"];\r\n    result.push(\r\n        (cell.isStart ? \"cell--is-start\" :\r\n            cell.isFinish ? \"cell--is-finish\" : \"\"));\r\n\r\n    return result.join(\" \");\r\n};\r\n\r\nconst Cell = (props: CellProps) => {\r\n    return (\r\n        <div id={\"cell-\" + props.cell.coordinate.row + \"-\" + props.cell.coordinate.col}\r\n             onClick={() => props.onClickHandler(props.cell)} className={getClass(props.cell)}/>\r\n    );\r\n};\r\n\r\nexport default Cell;\r\n","import {ICell, INode} from \"../types/GridTypes\";\r\n\r\nexport abstract class AbstractAlgorithm {\r\n    protected finishNode: INode | null;\r\n\r\n    protected constructor() {\r\n        this.finishNode = null;\r\n    }\r\n\r\n    abstract compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell>;\r\n\r\n    abstract getShortestPath(): Array<ICell>;\r\n}\r\n","/**\r\n * Binary heap (min-heap) used for dijkstra algorithm\r\n * Reference: https://medium.com/dev-genius/how-to-implement-a-binary-heap-javascript-d3a0c54112fa\r\n *\r\n * Insert: O(logn)\r\n * GetMin: O(logn)\r\n */\r\nimport {INode} from \"../types/GridTypes\";\r\n\r\nexport class MinHeap {\r\n    data: Array<INode>;\r\n\r\n    constructor() {\r\n        this.data = []\r\n    }\r\n\r\n    public insert(item: INode): void {\r\n        this.data.push(item);\r\n        this.reorganize(this.data.length - 1);\r\n    }\r\n\r\n    /**\r\n     * Reorganizes values in heap\r\n     */\r\n    private reorganize(index: number) {\r\n        let parentIndex = Math.floor((index + 1) / 2 - 1);\r\n        if (parentIndex < 0) parentIndex = 0;\r\n\r\n        let parentVal = this.data[parentIndex].distance;\r\n        const pushedVal = this.data[index].distance;\r\n        while (index > 0 && parentVal > pushedVal) {\r\n            parentIndex = Math.floor((index + 1) / 2 - 1);\r\n            this.swap(index, parentIndex);\r\n            index = parentIndex;\r\n            parentVal = this.data[Math.max(Math.floor((index + 1) / 2 - 1), 0)].distance;\r\n        }\r\n    }\r\n\r\n    private swap(index: number, parentIndex: number) {\r\n        let tmp = this.data[parentIndex]\r\n        this.data[parentIndex] = this.data[index];\r\n        this.data[index] = tmp;\r\n    }\r\n\r\n    /**\r\n     * Removes top element from heap\r\n     */\r\n    public removeTop(): INode | undefined {\r\n        if (this.data.length <= 1) return this.data.pop();\r\n\r\n        const ret: INode = this.data[0]; // What we will return\r\n        let temp = this.data.pop();\r\n        if (!temp) return temp;\r\n\r\n        this.data[0] = temp; // Place last element in array at front\r\n        let i = 0; // We adjust heap from top to down\r\n\r\n        while (true) {\r\n            let rightChildIndex = (i + 1) * 2;\r\n            let leftChildIndex = (i + 1) * 2 - 1;\r\n            let lowest = rightChildIndex;\r\n            if (leftChildIndex >= this.data.length && rightChildIndex >= this.data.length) break;\r\n\r\n            if (leftChildIndex >= this.data.length) lowest = rightChildIndex;\r\n            if (rightChildIndex >= this.data.length) lowest = leftChildIndex;\r\n\r\n            // Find the smallest child\r\n            if (!(leftChildIndex >= this.data.length) && !(rightChildIndex >= this.data.length)) {\r\n                lowest = this.data[rightChildIndex].distance < this.data[leftChildIndex].distance ? rightChildIndex : leftChildIndex;\r\n            }\r\n\r\n            // If the parent is greater than the smallest child: swap\r\n            if (this.data[i].distance > this.data[lowest].distance) {\r\n                this.swap(i, lowest);\r\n                i = lowest;\r\n            } else break;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","export function isEqual(obj1: Object, obj2: Object): boolean {\r\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\r\n}\r\n","import {AbstractAlgorithm} from \"./AbstractAlgorithm\";\r\nimport {cellToNode, ICell, INode} from \"../types/GridTypes\";\r\nimport {MinHeap} from \"../data-structures/MinHeap\";\r\nimport {isEqual} from \"../utils/Utils\";\r\n\r\n/**\r\n * Dijkstra is a Greedy algorithm\r\n *\r\n * Steps:\r\n * 1. Initialize start node with distance 0\r\n * 2. Get node with minimum distance from heap and add as visited\r\n * 3. getNeighbors from minimum distance node\r\n * 4. Remove current top node from heap and add Neighbor nodes to heap\r\n * 5. Repeat from 2 until endCell found\r\n */\r\nexport class Dijkstra extends AbstractAlgorithm {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    compute(grid: Array<ICell[]>, startCell: ICell, endCell: ICell): Array<ICell> {\r\n        let visitedCellsInOrder: Array<ICell> = [];\r\n\r\n        const start = {\r\n            cell: startCell,\r\n            distance: 0,\r\n            prev: null\r\n        };\r\n        let minHeap = new MinHeap();\r\n        minHeap.insert(start);\r\n\r\n        let isFinished = false;\r\n        while (!isFinished) {\r\n            let curr: INode | undefined = minHeap.removeTop();\r\n            if (curr) {\r\n                if (!curr.cell.isStart) {\r\n                    visitedCellsInOrder.push(curr.cell);\r\n                }\r\n\r\n                let neighbors: Array<INode> = this.findNeighbors(curr, grid);\r\n                neighbors.forEach(n => {\r\n                    if (isEqual(n.cell.coordinate, endCell.coordinate)) {\r\n                        isFinished = true;\r\n                        this.finishNode = n;\r\n                    } else if (!visitedCellsInOrder.includes(n.cell) && !minHeap.data.includes(n)\r\n                        && minHeap.data.filter(md => isEqual(md.cell.coordinate, n.cell.coordinate)).length === 0) {\r\n                        minHeap.insert(n);\r\n                    }\r\n                });\r\n            } else {\r\n                console.log(\"Undefined node\")\r\n                break;\r\n            }\r\n        }\r\n\r\n        return visitedCellsInOrder;\r\n    }\r\n\r\n    private findNeighbors(node: INode, grid: Array<ICell[]>) {\r\n        let neighbors: Array<INode> = [];\r\n        let {coordinate} = node.cell;\r\n\r\n        if (grid[coordinate.row + 1]) {\r\n            neighbors.push(cellToNode(grid[coordinate.row + 1][coordinate.col], node.distance + 1, node))\r\n        }\r\n        if (grid[coordinate.row - 1]) {\r\n            neighbors.push(cellToNode(grid[coordinate.row - 1][coordinate.col], node.distance + 1, node))\r\n        }\r\n        if (grid[coordinate.row][coordinate.col + 1]) {\r\n            neighbors.push(cellToNode(grid[coordinate.row][coordinate.col + 1], node.distance + 1, node))\r\n        }\r\n        if (grid[coordinate.row][coordinate.col - 1]) {\r\n            neighbors.push(cellToNode(grid[coordinate.row][coordinate.col - 1], node.distance + 1, node))\r\n        }\r\n\r\n        return neighbors;\r\n    }\r\n\r\n    getShortestPath(): Array<ICell> {\r\n        let shortestPath: Array<ICell> = [];\r\n\r\n        if (this.finishNode) {\r\n            let curr: INode = this.finishNode\r\n            while (curr?.prev) {\r\n                if (!curr.cell.isStart && !curr.cell.isFinish) {\r\n                    shortestPath.push(curr.cell);\r\n                }\r\n                curr = curr.prev;\r\n            }\r\n        }\r\n\r\n        return shortestPath.reverse();\r\n    }\r\n}\r\n","import React, {useEffect, useState} from 'react';\r\nimport \"./Grid.css\"\r\nimport Cell from \"../cell/Cell\";\r\nimport {Algorithm, GridConfiguration, ICell, OnClickEventType} from \"../../../types/GridTypes\";\r\nimport {Dijkstra} from \"../../../algorithms/Dijkstra\";\r\n\r\nlet INIT_START: ICell = {\r\n    coordinate: {\r\n        row: 10,\r\n        col: 5\r\n    },\r\n    isStart: true,\r\n    isFinish: false,\r\n};\r\n\r\nlet INIT_END: ICell = {\r\n    coordinate: {\r\n        row: 14,\r\n        col: 15\r\n    },\r\n    isStart: false,\r\n    isFinish: true,\r\n};\r\n\r\nconst computeInitialGrid = (config: GridConfiguration, startCell: ICell, endCell: ICell): Array<ICell[]> => {\r\n    let grid = []\r\n    for (let row = 0; row < config.numRows; row++) {\r\n        let currRow: ICell[] = [];\r\n\r\n        for (let col = 0; col < config.numColumns; col++) {\r\n            currRow.push({\r\n                isStart: col === startCell.coordinate.col && row === startCell.coordinate.row,\r\n                isFinish: col === endCell.coordinate.col && row === endCell.coordinate.row,\r\n                coordinate: {\r\n                    row: row,\r\n                    col: col\r\n                },\r\n            })\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst Grid = (config: GridConfiguration) => {\r\n    const [grid, setGrid] = useState<Array<ICell[]>>([[]]);\r\n    const [algorithm, setAlgorithm] = useState<Algorithm>({name: \"\", instance: new Dijkstra()});\r\n    const [onClickType, setOnClickType] = useState<OnClickEventType>(OnClickEventType.SET_START);\r\n    const [startCell, setStartCell] = useState<ICell>(INIT_START);\r\n    const [endCell, setEndCell] = useState<ICell>(INIT_END);\r\n    const [isRunning, setRunning] = useState(false);\r\n    const [visitedElements, setVisitedElements] = useState<Array<Element>>([]);\r\n\r\n    const handleOnClick = (cell: ICell) => {\r\n        if (isRunning) return\r\n\r\n        switch (onClickType) {\r\n            case OnClickEventType.SET_START:\r\n                startCell.isStart = false;\r\n                cell.isStart = true\r\n                setStartCell(cell);\r\n                break;\r\n            case OnClickEventType.SET_FINISH:\r\n                endCell.isFinish = false;\r\n                cell.isFinish = true\r\n                setEndCell(cell);\r\n                break;\r\n        }\r\n    };\r\n\r\n    const startAlgorithm = () => {\r\n        clearBoard();\r\n        setRunning(true)\r\n        const visitedCells = algorithm.instance.compute(grid, startCell, endCell);\r\n        const shortestPath = algorithm.instance.getShortestPath();\r\n        animate(visitedCells, shortestPath);\r\n    }\r\n\r\n    const animate = (visited: Array<ICell>, shortestPath: Array<ICell>) => {\r\n        let visitedEl: Array<Element> = []\r\n        for (let i = 0; i < visited.length; i++) {\r\n            setTimeout(() => {\r\n                let currCell = visited[i]\r\n                let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                if (el) {\r\n                    el.classList.add(\"cell--is-visited\");\r\n                    visitedEl.push(el)\r\n                }\r\n            }, 10 * i)\r\n        }\r\n\r\n        // show shortest path after visited nodes are visualized\r\n        setTimeout(() => {\r\n            // animate shortest path\r\n            for (let i = 0; i < shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    let currCell = shortestPath[i]\r\n                    let el = document.getElementById(\"cell-\" + currCell.coordinate.row + \"-\" + currCell.coordinate.col);\r\n                    if (el) {\r\n                        el.classList.add(\"cell--is-shortest-path\");\r\n                    }\r\n                }, 30 * i)\r\n            }\r\n\r\n            setTimeout(() => {\r\n                setVisitedElements(visitedEl);\r\n                setRunning(false)\r\n            }, 10 * shortestPath.length)\r\n        }, 10 * visited.length)\r\n    }\r\n\r\n    const clearBoard = () => {\r\n        for (let el of visitedElements) {\r\n            el.classList.remove(\"cell--is-visited\")\r\n            el.classList.remove(\"cell--is-shortest-path\")\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        clearBoard();\r\n        setGrid(computeInitialGrid(config, startCell, endCell));\r\n    }, [config, startCell, endCell])\r\n\r\n    const handleAlgorithmSelection = (e: React.ChangeEvent<HTMLSelectElement>) => {\r\n        setAlgorithm(config.algorithms[parseInt(e.target.value)])\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <div className=\"algorithm-selection\">\r\n                <label>Select Algorithm:</label>\r\n                <div className=\"custom-select\">\r\n                    <select onChange={(e) => handleAlgorithmSelection(e)}>\r\n                        {\r\n                            config.algorithms.map((algo, idx) => {\r\n                                return <option key={idx} value={idx}>{algo.name}</option>\r\n                            })\r\n                        }\r\n                    </select>\r\n                </div>\r\n\r\n                <button className=\"start-btn\" disabled={isRunning}\r\n                        onClick={() => startAlgorithm()}>\r\n                    Start Visualization\r\n                </button>\r\n            </div>\r\n\r\n            <div style={{display: \"flex\", justifyContent: \"center\"}}>\r\n                <p>\r\n                    <input id=\"setStart\" type=\"radio\" value={OnClickEventType.SET_START} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_START}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_START)}/>\r\n                    <label htmlFor={\"setStart\"}>Set Start</label>\r\n                </p>\r\n\r\n                <p>\r\n                    <input id=\"setFinish\" type=\"radio\" value={OnClickEventType.SET_FINISH} name=\"onClickEventType\"\r\n                           checked={onClickType === OnClickEventType.SET_FINISH}\r\n                           onChange={() => setOnClickType(OnClickEventType.SET_FINISH)}/>\r\n                    <label htmlFor={\"setFinish\"}>Set Finish</label>\r\n                </p>\r\n            </div>\r\n\r\n            <div>\r\n                <div className=\"grid__container\">\r\n                    {\r\n                        grid.map((row, rowIdx) => {\r\n                            return <div key={rowIdx} className=\"grid__container__row\">\r\n                                {row.map((cell, cellIdx) => <Cell key={cellIdx} cell={cell}\r\n                                                                  onClickHandler={(cell: ICell) => handleOnClick(cell)}/>)}\r\n                            </div>\r\n                        })\r\n                    }\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Grid;\r\n","import React from 'react';\r\nimport Grid from \"../components/table/grid/Grid\";\r\nimport {GridConfiguration} from \"../types/GridTypes\";\r\nimport {Dijkstra} from \"../algorithms/Dijkstra\";\r\n\r\nconst gridConfiguration: GridConfiguration = {\r\n    numColumns: 50,\r\n    numRows: 20,\r\n    algorithms: [\r\n        {\r\n            name: \"Dijkstra\",\r\n            instance: new Dijkstra()\r\n        }\r\n    ]\r\n};\r\n\r\nconst Main = () => {\r\n    return (\r\n        <div>\r\n            <Grid {...gridConfiguration} />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Main;\r\n","import React from 'react';\nimport './App.css';\nimport Main from \"./pages/main\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Main/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}